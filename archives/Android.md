- [Android](#android)
  - [Android Developer](#android-developer)
  - [GitHub](#github)
  - [公众号](#公众号)
  - [技术网站](#技术网站)
  - [技术笔记](#技术笔记)
  - [AndroidX Jetpack](#androidx-jetpack)
    - [Navigation](#navigation)

---

![Android Icon](https://developer.android.com/images/home/droid.svg)

## [Android](#)

- [Android 官网](https://www.android.com)

### [Android Developer](#)

- [Android 开发者](https://developer.android.com/?hl=zh-cn)
  - [Android Jetpack 开发资源 - Android 开发者](https://developer.android.com/jetpack?hl=zh-cn)
  - [按类型探索 Jetpack 库](https://developer.android.com/jetpack/androidx/explorer?hl=zh-cn)
  - [Jetpack Compose 界面应用开发工具包 - Android 开发者](https://developer.android.com/jetpack/compose?hl=zh-cn)
  - [Android Code Search](https://cs.android.com)

### [GitHub](#)

- [android/architecture-samples](https://github.com/android/architecture-samples)
- [android/architecture-components-samples](https://github.com/android/architecture-components-samples)
- [androidx/androidx](https://github.com/androidx/androidx)
- [flutter/flutter](https://github.com/flutter/flutter)
- [square/okhttp](https://github.com/square/okhttp)
- [square/retrofit](https://github.com/square/retrofit)
- [wasabeef/awesome-android-ui](https://github.com/wasabeef/awesome-android-ui)

### [公众号](#)

- [Android](https://mp.weixin.qq.com/mp/homepage?__biz=Mzk0NDIwMTExNw==&hid=1&sn=0ed6d0fd58ab63011c5b1636671eee4d&scene=18)
- [Kotlin](https://mp.weixin.qq.com/mp/homepage?__biz=Mzk0NDIwMTExNw==&hid=11&sn=da2f30251fe7cb46fcad3e4af67e85a9&scene=18)
- [Jetpack Compose](https://mp.weixin.qq.com/mp/homepage?__biz=Mzk0NDIwMTExNw==&hid=13&sn=92a0fbf8f1b75db9d1db83e858da83fd&scene=18)
- [Jetpack](https://mp.weixin.qq.com/mp/homepage?__biz=Mzk0NDIwMTExNw==&hid=12&sn=9ae81df4393d5d1ec6967cffccef4b58&scene=18)
- [Android Studio](https://mp.weixin.qq.com/mp/homepage?__biz=Mzk0NDIwMTExNw==&hid=14&sn=4f9fba25580f434fdfc8ecf63b2c6ec4&scene=18)

### [技术网站](#)

- [玩 Android](https://wanandroid.com)

### [技术笔记](#)

- [橘子树的写作记录](https://ghcljx72eo.feishu.cn/wiki/wikcnVeYSGCSyyvoklY76Hrxpmb)

**Android Performance 系列文章**

1. - [ ] [Android Systrace 基础知识 -- Systrace 简介](https://www.androidperformance.com/2019/05/28/Android-Systrace-About)
2. - [ ] [Android Systrace 基础知识 -- 分析 Systrace 预备知识](https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre)
3. - [ ] [Android Systrace 基础知识 -- Why 60 fps ？](https://www.androidperformance.com/2019/05/27/why-60-fps)
4. - [ ] [Android Systrace 基础知识 - SystemServer 解读](https://www.androidperformance.com/2019/06/29/Android-Systrace-SystemServer)
5. - [ ] [Android Systrace 基础知识 - SurfaceFlinger 解读](https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger)
6. - [ ] [Android Systrace 基础知识 - Input 解读](https://www.androidperformance.com/2019/11/04/Android-Systrace-Input)
7. - [ ] [Android Systrace 基础知识 - Vsync 解读](https://www.androidperformance.com/2019/12/01/Android-Systrace-Vsync)
8. - [ ] [Android 基于 Choreographer 的渲染机制详解](https://androidperformance.com/2019/10/22/Android-Choreographer)
9. - [ ] [Android Systrace 基础知识 - MainThread 和 RenderThread 解读](https://www.androidperformance.com/2019/11/06/Android-Systrace-MainThread-And-RenderThread)
10. - [ ] [Android Systrace 基础知识 - Binder 和锁竞争解读](https://www.androidperformance.com/2019/12/06/Android-Systrace-Binder)
11. - [ ] [Android Systrace 基础知识 - Triple Buffer 解读](https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer)
12. - [ ] [Android Systrace 基础知识 - CPU Info 解读](https://www.androidperformance.com/2019/12/21/Android-Systrace-CPU)
13. - [ ] [Android Systrace 流畅性实战 1 ：了解卡顿原理](https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1)
14. - [ ] [Android Systrace 流畅性实战 2 ：案例分析 - MIUI 桌面滑动卡顿分析](https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-2)
15. - [ ] [Android Systrace 流畅性实战 3 ：卡顿分析过程中的一些疑问](https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-3)
16. - [ ] [Android Systrace 响应速度实战 1 ：了解响应速度原理](https://www.androidperformance.com/2021/09/13/android-systrace-Responsiveness-in-action-1)
17. - [ ] [Android Systrace 响应速度实战 2 ：响应速度实战分析-以启动速度为例](https://www.androidperformance.com/2021/09/13/android-systrace-Responsiveness-in-action-2)
18. - [ ] [Android Systrace 响应速度实战 3 ：响应速度延伸知识](https://www.androidperformance.com/2021/09/13/android-systrace-Responsiveness-in-action-3)
19. - [ ] [Systrace 线程 CPU 运行状态分析技巧 - Runnable 篇](https://www.androidperformance.com/2022/01/21/android-systrace-cpu-state-runnable)
20. - [ ] [Systrace 线程 CPU 运行状态分析技巧 - Running 篇](https://www.androidperformance.com/2022/03/13/android-systrace-cpu-state-running)
21. - [ ] [Systrace 线程 CPU 运行状态分析技巧 - Sleep 和 Uninterruptible Sleep 篇](https://www.androidperformance.com/2022/03/13/android-systrace-cpu-state-sleep)

### [AndroidX Jetpack](#)

#### [Navigation](#)

<details><summary><b>问题：请详细说明 Navigation 组件的使用场景以及与传统 Fragment 事务的比较。</b></summary>

<br>

> 在回答这个问题时，要突出 Navigation 组件的优势，以及它在处理导航和页面交互时相对于传统 Fragment 事务的创新之处。

Navigation 组件是 Jetpack 中用于处理应用内导航的强大工具。它的使用场景包括但不限于：
- 单一活动多 Fragment 架构：通过将所有 Fragment 集中在一个活动中，简化了导航的管理和传递数据的复杂性。
- 深层链接：支持通过深层链接直接导航到应用中的特定目标，提高用户体验。
- 类型安全的导航：使用安全 Args 插件，避免了传统 Bundle 传递参数时的类型错误。

相对于传统 Fragment 事务，Navigation 组件的优势在于：
- 导航图的可视化：使用导航图直观展示应用中的导航流程，方便理解和修改。
- 类型安全：利用 Kotlin 的类型安全特性，减少在导航时的错误。
- 生命周期感知：自动处理 Fragment 的生命周期，避免了一些常见的生命周期相关问题。

</details>

<details><summary><b>问题：请解释 Navigation 组件的作用，并介绍 Navigation 组件的核心组件以及它们之间的关系。</b></summary>

<br>

> 出发点：解释说明 Navigation 的几个核心组件，以及他们的作用。

参考简答：

其作用和核心组件包括：

作用：Navigation 组件用于实现应用内的导航结构，使得从一个目的地（Destination）到另一个目的地的导航变得更加容易管理和统一。

核心组件：

- NavGraph（导航图）：包含应用中所有目的地和它们之间的导航关系。
- NavController（导航控制器）：管理导航操作的控制器，负责管理与目的地的交互。
- NavDestination（导航目的地）：表示导航图中的一个页面或操作，定义了目的地的属性和行为。

这三个核心组件共同构建了整个导航体系，使得在 Android 应用中实现复杂的导航结构变得更加简单和可维护。

</details>

Code:

```Kotlin
import android.app.Activity
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import com.google.zxing.BinaryBitmap
import com.google.zxing.ChecksumException
import com.google.zxing.DecodeHintType
import com.google.zxing.FormatException
import com.google.zxing.NotFoundException
import com.google.zxing.Result
import com.google.zxing.common.HybridBinarizer
import com.google.zxing.qrcode.QRCodeReader
import com.google.zxing.RGBLuminanceSource

class MainActivity : AppCompatActivity() {

    private val REQUEST_CODE_PICK_IMAGE = 100

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 启动选择图片的Intent
        val intent = Intent(Intent.ACTION_PICK)
        intent.type = "image/*"
        startActivityForResult(intent, REQUEST_CODE_PICK_IMAGE)
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == REQUEST_CODE_PICK_IMAGE && resultCode == Activity.RESULT_OK) {
            data?.data?.let { uri ->
                val originalBitmap = getBitmapFromUri(uri)
                val processedBitmap = originalBitmap?.let { processBitmap(it) }

                // 回收原始位图
                originalBitmap?.recycle()

                processedBitmap?.let {
                    decodeQRCode(it)
                    // 用完后回收处理后的位图
                    it.recycle()
                }
            }
        }
    }

    private fun getBitmapFromUri(uri: Uri): Bitmap? {
        return contentResolver.openInputStream(uri)?.use { stream ->
            BitmapFactory.decodeStream(stream)
        }
    }

    private fun processBitmap(bitmap: Bitmap): Bitmap {
        return bitmap.convertToGrayscale().binarize()
    }

    private fun Bitmap.convertToGrayscale(): Bitmap {
        val width = this.width
        val height = this.height
        val grayBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)

        for (y in 0 until height) {
            for (x in 0 until width) {
                val pixel = this.getPixel(x, y)
                val r = (pixel shr 16) and 0xff
                val g = (pixel shr 8) and 0xff
                val b = pixel and 0xff
                val gray = (0.299 * r + 0.587 * g + 0.114 * b).toInt()
                grayBitmap.setPixel(x, y, (0xff shl 24) or (gray shl 16) or (gray shl 8) or gray)
            }
        }

        return grayBitmap
    }

    private fun Bitmap.binarize(): Bitmap {
        val width = this.width
        val height = this.height
        val binarizedBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        
        for (y in 0 until height) {
            for (x in 0 until width) {
                val pixel = this.getPixel(x, y)
                val gray = (pixel shr 16) and 0xff
                val binary = if (gray > 128) 0xffffff else 0x000000
                binarizedBitmap.setPixel(x, y, binary)
            }
        }

        return binarizedBitmap
    }

    private fun decodeQRCode(bitmap: Bitmap) {
        val width = bitmap.width
        val height = bitmap.height
        val pixels = IntArray(width * height)
        bitmap.getPixels(pixels, 0, width, 0, 0, width, height)

        val source = RGBLuminanceSource(width, height, pixels)
        val binaryBitmap = BinaryBitmap(HybridBinarizer(source))
        val qrCodeReader = QRCodeReader()
        val hints = mapOf(DecodeHintType.TRY_HARDER to true)

        try {
            val result: Result = qrCodeReader.decode(binaryBitmap, hints)
            println("QR Code content: ${result.text}")
        } catch (e: NotFoundException) {
            println("QR Code not found")
        } catch (e: ChecksumException) {
            println("Error decoding QR Code")
        } catch (e: FormatException) {
            println("Error decoding QR Code")
        }
    }
}
```
